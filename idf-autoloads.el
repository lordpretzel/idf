;;; idf-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory #$) (car load-path))))



;;; Generated autoloads from idf.el

(autoload 'idf-maintain "idf" "\
Incrementally maintain materialized dataframe DF based on UPDATES.

We return the delta for DF generated by the maintenance. For
literal datasources (`idf-source-literal') updates have to be
provided explicitly as parameter UPDATES. For function data
sources (`idf-source-fn') , we will call
`idf-source-fn-update-fn'.

(fn DF UPDATES)")
(autoload 'idf-maintain-multiple "idf" "\
Given list of dataframes DFS, apply UPDATES.

We incrementally maintain the results for all these dataframes.
Importantly, operators in the dataflow graphs may be shared
across the dataframes and we take care to only update the result
of each operator once.

(fn DFS UPDATES &optional DELTA-CACHE)")
(autoload 'idf-map "idf" "\
Create dataframe that maps MAPFN to input DF.

If RESULTSCHEMA is provided, then use it as the schema for the
returned dataframe. For datasets provide TYPE to store the type
of result. Otherwise, keep schema undecided (nil).

(fn DF MAPFN &key RESULTSCHEMA TYPE)")
(autoload 'idf-reduce "idf" "\
Create dataframe DF that applies REDUCEFN to merge input into a single row.

If INITVAL is non-nil, then initialize the result to INITVAL. If
RESULTSCHEMA is provided then rename attributes accordingly. If
GROUPATTRS is non-nil, then group the rows of the dataframe on
these columns and apply the reducer to every group.
Alternatively, GROUPFN can be used to determine the key of
input (inputs with the same key are put into the same group.

(fn DF &key REDUCEFN GROUPFN GROUPATTRS INITVAL TYPE RESULTSCHEMA)")
(autoload 'idf-create-source "idf" "\
Create a idf source dataframe named NAME.

A source dataframe is either created from some existing CONTENT (a list) or
using a function that returns the content (GENERATORFN). If a
source's content changes over time then a UPDATEFN should be
provided that returns a `idf-delta` which stores which elements
have been inserted and deleted from the source. Typically idf
dataframes are lists of lists where the inner lists are alists with
a fixed SCHEMA that can be provided as an input to this function.

(fn &key NAME CONTENT GENERATORFN UPDATEFN SCHEMA)")
(autoload 'idf-project "idf" "\
Project a dataframe DF (which has to have a schema) on ATTRS.

if RESULTSCHEMA is provided, then rename attributes like this.

(fn DF &key ATTRS RESULTSCHEMA)")
(autoload 'idf-filter "idf" "\
Filter the rows of DF.

If EXPR is provided then generate a function based on the EXPR.
Any symbol $NAME in EXPR will be replaced with the value of the
attribute NAME, e.g., `(< $A $B)` would filter out all rows where
the value of attribute A is smaller than the one of attribute B.
If FN is provided the evaluate FN on every input row and if it
returns nil, then filter out the row.

(fn DF &key EXPR FN)")
(autoload 'idf-union "idf" "\
Union LEFTDF and RIGHTDF.

(fn LEFTDF RIGHTDF &optional SCHEMA)")
(autoload 'idf-unique "idf" "\
Remove duplicates from DF.

If KEYEXTRACTOR is used extract a key from tuples to determine
equality for duplicate elimination. If SCHEMA is provided then
rename the result attributes using SCHEMA.

(fn DF &key SCHEMA KEYEXTRACTOR)")
(autoload 'idf-aggregate "idf" "\
Group DF on GROUP-BY attributes.

Then compute aggregation functions AGGS for each group.
Optionally, the attribute names for the result can be provided as
parameter SCHEMA. Essentially, this is a specifialized version of
`idf-reduce' which uses one of a fixed set of aggregation
functions. The implementation exploits the properties of the
aggregation functions to improve performance, e.g., for a `sum' we
can incrementally maintain the sum by updating the current result
as follows: inserted values are added to the current sum while
deleted values are subtracted from the current sum.

Currently, the following aggregates are supported:
- `sum'
- `avg'
- `min'
- `max'

(fn DF &key GROUP-BY AGGS SCHEMA)")
(autoload 'idf-equi-join "idf" "\
Join LEFT-DF with RIGHT-DF on equality.

Attributes LEFT-ATTRS and RIGHT-ATTRS and the attributes from
LEFT-DF (RIGHT_DF) we are joining on. Rename the result
attributes using SCHEMA (if provided). If MERGE-FN is provided
then this function (which has to take two arguments) will be
applied to every pair of matching elements to produce a result
element. The default function is to appedn the two input
elements (plists). If JOIN-TYPE is provided, then use this join
type (`inner', `left-outer', `right-outer', and `'full-outer'.

(fn LEFT-DF RIGHT-DF &key LEFT-ATTRS RIGHT-ATTRS SCHEMA MERGE-FN JOIN-TYPE)")
(register-definition-prefixes "idf" '("idf-" "with-"))


;;; End of scraped data

(provide 'idf-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; idf-autoloads.el ends here
